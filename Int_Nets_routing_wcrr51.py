from typing import List, Tuple
import heapq


"""
Routing algorithm for the bubble-sort interconnection network.
"""
def bubblesort_routing(
        n: int, source: List[int],
        destination: List[int]
    ) -> List[List[int]]:
    assert len(source) == n and len(destination) == n, "Dimension missmatch"

    # Put the source node in the routing
    routing = [source.copy()]
    # Variable to store the current node
    current_node = source.copy()
    # Working from back to front, for each digit index j in the destination label
    for j in reversed(range(n)):
        # Scan through the current node up to (but not including) the destination digit at index j
        for i in range(j):
            # If the current node position is the destination digit
            if current_node[i] == destination[j]:
                # Swap the current node digit with its next one
                current_node[i], current_node[i + 1] = current_node[i + 1], current_node[i]
                # Add the new node generated by the swap to the routing
                routing.append(current_node.copy())

    # Return the calculated routing
    return routing


"""
Analysis for the bubble-sort interconnection network.
"""
def bubblesort_stats(
        n: int,
        sources: List[List[int]],
        destinations: List[List[int]],
        verbose: bool = False
    ) -> None:
    assert len(sources) == len(destinations), "Sources do not match destinations"
    
    max_path_length = 0
    total_path_length = 0

    node_loads = {}
    channel_loads = {}

    count_ex_matches = 0

    for source, destination in zip(sources, destinations):
        routing = bubblesort_routing(n, source, destination)
        path_length = len(routing) - 1
        
        if verbose:
            print(f"{source} -> {destination} : [{path_length}] {routing}")
        if max_path_length < path_length:
            max_path_length = path_length
        total_path_length += path_length

        if source != destination:
            count_ex_matches += 1
        
        for i in range(path_length):
            next_node = tuple(routing[i + 1])
            if next_node not in node_loads:
                node_loads[next_node] = 0
            node_loads[next_node] += 1
            
            channel = (tuple(routing[i]), tuple(next_node))
            if channel not in channel_loads:
                channel_loads[channel] = 0
            channel_loads[channel] += 1

    sampled_channels = [
        (tuple(range(n)), tuple([1, 0] + list(range(2, n)))),
        (tuple([1, 0] + list(range(2, n))), tuple(range(n)))
    ]
    sampled_channel_loads = {sampled_channel: channel_loads[sampled_channel] for sampled_channel in sampled_channels}

    sampled_nodes = [tuple(range(n)), tuple([1, 0] + list(range(2, n)))]
    sampled_node_loads = {sampled_node: node_loads[sampled_node] for sampled_node in sampled_nodes}

    channel_min_load = min(channel_loads, key=channel_loads.get)
    channel_max_load = max(channel_loads, key=channel_loads.get)
    total_channel_load = sum(channel_loads.values())

    node_min_load = min(node_loads, key=node_loads.get)
    node_max_load = max(node_loads, key=node_loads.get)
    total_node_load = sum(node_loads.values())

    load_channels = {}
    for channel, load in channel_loads.items():
        if load not in load_channels:
            load_channels[load] = 0
        load_channels[load] += 1

    load_nodes = {}
    for node, load in node_loads.items():
        if load not in load_nodes:
            load_nodes[load] = 0
        load_nodes[load] += 1

    print(
        f"n = {n}\n"
        f"len(sources) = len(destinations) = {len(sources)}\n"
        f"count_ex_matches = {count_ex_matches}\n"
        f"max_path_length = {max_path_length}\n"
        f"total_path_length = {total_path_length}\n"
        f"average_path_length = {total_path_length / len(sources)}\n"
        f"average_path_length_ex_matches = {total_path_length / count_ex_matches}\n"
        f"sampled_channel_loads = {sampled_channel_loads}\n"
        f"min_channel_load = {channel_loads[channel_min_load]} ({channel_min_load})\n"
        f"max_channel_load = {channel_loads[channel_max_load]} ({channel_max_load})\n"
        f"total_channel_load = {total_channel_load}\n"
        f"average_channel_load = {total_channel_load / len(channel_loads)}\n"
        f"load_channels = {load_channels}\n"
        f"sampled_node_loads = {sampled_node_loads}\n"
        f"min_node_load = {node_loads[node_min_load]} ({node_min_load})\n"
        f"max_node_load = {node_loads[node_max_load]} ({node_max_load})\n"
        f"total_node_load = {total_node_load}\n"
        f"average_node_load = {total_node_load / len(node_loads)}\n"
        f"load_nodes = {load_nodes}"
    )


"""
Fault-tolerant hypercube routing algorithm using BFS (dfs = False) or DFS (dfs = True).
(DO NOT MARK, actual algorithm is faulty_hypercube_routing though I'd be interested to see how this does on your tests)
"""
def faulty_hypercube_routing_dbfs(
        n: int,
        source: List[int],
        destination: List[int],
        faulty_nodes: List[int],
        faulty_channels: List[Tuple[int, int]],
        dfs: bool = True
    ) -> List[List[int]]:
    assert len(source) == n and len(destination) == n, "Dimension missmatch"
    faulty_channels = [(node_a, node_b) for node_a, node_b in faulty_channels]

    # Initialise the path queue and visited nodes set to only include the source node
    path_queue = [[source]]
    visited = [source]

    # While there are still paths in the queue to consider
    while path_queue:
        # Fetch the path at the front of the queue
        current_path = path_queue.pop(-int(dfs))

        # If the node at the end of the path is the destination
        if current_path[-1] == destination:
            assert all([node not in faulty_nodes for node in current_path]), "Faulty node in routing"
            assert all([(current_path[i], current_path[i + 1]) not in faulty_channels for i in range(len(current_path) - 1)]), "Faulty channel in routing"
            # Return the routing
            return current_path

        # If we are not at the destination, loop through each hypercube dimenion i
        for i in range(n):
            # Calculate the candidate node made by flipping the bit in dimenion i
            candidate_node = [
                bit ^ 1 if j == i else bit
                for j, bit in enumerate(current_path[-1])
            ]
            # Calculate the candidate channel corresponding to the bit flip
            candidate_channel = (current_path[-1], candidate_node)

            # If the candidate node has already been visited, is faulty, or the channel is faulty
            if candidate_node in visited or \
               candidate_node in faulty_nodes or \
               candidate_channel in faulty_channels:
                # Ignore this candidate and consider to the next
                continue

            # Calculate the candidate path formed from the current path and candidate node
            candidate_path = current_path + [candidate_node]
            # Add the candidate node to the list of visited nodes
            visited.append(candidate_node)
            # Add the candidate path to the queue
            path_queue.append(candidate_path)

    # If no routing is found, return the source node only
    return [source]


"""
Fault-tolerant hypercube routing algorithm using A* search with hamming distance as the heuristic.
"""
def faulty_hypercube_routing(
        n: int,
        source: List[int],
        destination: List[int],
        faulty_nodes: List[int],
        faulty_channels: List[Tuple[int, int]]
    ) -> List[List[int]]:
    assert len(source) == n and len(destination) == n, "Dimension missmatch"

    # Convert the faulty_channels, faulty_nodes, source, and destination to tuples so they can be hashed
    faulty_channels = [(tuple(node_a), tuple(node_b)) for node_a, node_b in faulty_channels]
    faulty_nodes = set(map(tuple, faulty_nodes))
    source, destination = tuple(source), tuple(destination)

    # A* heuristic is the hamming distance between a node and the destination
    # Satisfies h(node, node) = 0 and h(node, node') > 0 iff node != node'
    def h(node, destination):
        return sum([a ^ b for a, b in zip(node, destination)])

    # Initialise the node queue to the source, prioritised by its hamming distance to the destination
    node_queue = [(h(source, destination), source)]
    # Initialise the set of node parents (for back-tracking) to only contain the source
    node_parent = {source: None}
    # Initialise the visited node hop counts to the source (with a hop count of 0)
    visited_hops = {source: 0}

    # While the node queue is not empty...
    while node_queue:
        # Pop the lowest-priority node from the queue
        _, current_node = heapq.heappop(node_queue)

        # If the current node is the destination node
        if current_node == destination:
            # Backtrack through node_parent to find the routing
            routing = []
            routing_node = current_node
            while True:
                # Convert each node from a tuple back to a list
                routing.insert(0, list(current_node))
                current_node = node_parent[current_node]
                if current_node is None:
                    break
            # Check the routing does not cross faulty nodes or channels
            try:
                assert all([tuple(node) not in faulty_nodes for node in routing]), "Faulty node in routing"
                assert all([(tuple(routing[i]), tuple(routing[i + 1])) not in faulty_channels for i in range(len(routing) - 1)]), "Faulty channel in routing"
            except AssertionError as e:
                print(e)
                break
            # Return the routing
            return routing

        # If we are not at the destination, loop through each hypercube dimension i
        for i in range(n):
            # Calculate the candidate node made by flipping the bit in dimenion i
            candidate_node = tuple([
                bit ^ 1 if j == i else bit
                for j, bit in enumerate(current_node)
            ])
            # Calculate the candidate channel corresponding to the bit flip
            candidate_channel = (current_node, candidate_node)
            # Calculate the total hop count for the candidate node
            candidate_hops = visited_hops[current_node] + 1

            # If the candidate node has already been visited, is faulty, or the channel is faulty
            if (candidate_node in visited_hops and \
               candidate_hops >= visited_hops[candidate_node]) or \
               candidate_node in faulty_nodes or \
               candidate_channel in faulty_channels:
                # Ignore this candidate and consider to the next
                continue

            # Add the candidate node to the list of visited nodes
            visited_hops[candidate_node] = candidate_hops
            # Calculate the candidate priority for the next iteration using the hop count and heuristic
            candidate_priority = candidate_hops + h(candidate_node, destination)
            # Add the candidate path to the node queue
            heapq.heappush(node_queue, (candidate_priority, candidate_node))
            # Add the current node as the parent of the candidate
            node_parent[candidate_node] = current_node

    # If no routing is found, return the source node only
    return [list(source)]
